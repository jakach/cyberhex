#include <nanogui/nanogui.h>
#include <thread>
#include <chrono>
#include <atomic>
#include <iostream>
#include <shlobj.h>
#include <windows.h>
#include <locale>
#include <codecvt>
#include <fstream>
#include "../client_backend/well_known.h"

// Function to add a message to the scrollable field
void addMessage(nanogui::Widget* scrollContent, const std::string& message) {
    nanogui::Label* label = new nanogui::Label(scrollContent, message);
    label->setFixedWidth(600);
    //label->setWordWrap(true);
}

// Function to simulate file scanning
void scan_file(nanogui::Screen* screen, const std::string& filePath) {
    // Remove the answer file
    std::remove(ANSWER_COM_PATH);
    // Display the scanned file path in the window
    auto scrollContent = new nanogui::Widget(screen);
    screen->setLayout(new nanogui::BoxLayout(nanogui::Orientation::Vertical, nanogui::Alignment::Minimum, 0, 0));
    addMessage(scrollContent, "Scanning file: " + filePath + "\n");
    screen->performLayout();
    bool answered = false;
    // Write command into com file
    std::ofstream outputFile(MAIN_COM_PATH);
    if (outputFile.is_open()) {
        outputFile << "scanfile \"" << filePath << "\"";
        outputFile.close();
    }
    else {
        addMessage(scrollContent, "Error: Unable to talk to daemon!\n");
        screen->performLayout();
        return;
    }
    while (!answered) {
        // Wait for answer in file
        std::ifstream inputFile(ANSWER_COM_PATH);
        // The structure of the answer file is as follows:
        // found/not_found
        // filepath
        // hash
        // action_taken/no_action_taken
        if (inputFile.is_open()) {
            std::string status, scannedFilePath, hash, action;
            if (inputFile >> status) {
                inputFile.ignore(1); // Ignore space
                inputFile.ignore(1); // Ignore starting double quote
                if (status == "found" || status == "not_found") {
                    std::getline(inputFile, scannedFilePath, '\"'); // Read until closing double quote
                    inputFile.ignore(1); // Ignore space between filepath and hash
                    inputFile.ignore(1); // Ignore starting double quote
                    std::getline(inputFile, hash, ' '); // Read until space
                    std::getline(inputFile, action); // Read until end of line

                    answered = true;

                    if (status == "found") {
                        addMessage(scrollContent, "Virus found in file: " + scannedFilePath + "\n");
                        addMessage(scrollContent, "File: " + scannedFilePath + " is infected\n");
                        addMessage(scrollContent, "Hash: " + hash + "\n");
                        addMessage(scrollContent, "Action taken: " + action + "\n");
                    }
                    else {
                        addMessage(scrollContent, "No virus found in file: " + scannedFilePath + "\n");
                        addMessage(scrollContent, "File: " + scannedFilePath + " is not infected\n");
                    }
                    addMessage(scrollContent, "------------------------------------------");
                    screen->performLayout();
                }
            }
            else {
                answered = true;
                addMessage(scrollContent, "Error: Unable to talk to daemon!\n");
                addMessage(scrollContent, "------------------------------------------");
                screen->performLayout();
            }
            inputFile.close();
            std::remove(ANSWER_COM_PATH);
        }
        // Wait for 1 second before checking again
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    // Remove the answer file
    std::remove(ANSWER_COM_PATH);
}

// Function to simulate folder scanning
void scan_folder(nanogui::Screen* screen, const std::string& folderPath) {
    // Remove the answer file
    std::remove(ANSWER_COM_PATH);
    // Display the scanned folder path in the window
    auto scrollContent = new nanogui::Widget(screen);
    screen->setLayout(new nanogui::BoxLayout(nanogui::Orientation::Vertical, nanogui::Alignment::Minimum, 0, 0));
    addMessage(scrollContent, "Scanning folder: " + folderPath + "\n");
    screen->performLayout();
    bool answered = false;
    // Write command into com file
    std::ofstream outputFile(MAIN_COM_PATH);
    if (outputFile.is_open()) {
        outputFile << "scanfolder \"" << folderPath << "\"";
        outputFile.close();
    }
    else {
        addMessage(scrollContent, "Error: Unable to talk to daemon!\n");
        screen->performLayout();
        return;
    }
    while (!answered) {
        // Wait for answer in file
        std::ifstream inputFile(ANSWER_COM_PATH);
        // The structure of the answer file is as follows:
        // found/not_found
        // filepath
        // hash
        // action_taken/no_action_taken
        if (inputFile.is_open()) {
            std::string status, scannedFilePath, hash, action;
            while (!inputFile.eof()) {
                if (inputFile >> status) {
                    inputFile.ignore(1); // Ignore space
                    inputFile.ignore(1); // Ignore starting double quote
                    if (status == "found" || status == "not_found") {
                        std::getline(inputFile, scannedFilePath, '\"'); // Read until closing double quote
                        inputFile.ignore(1); // Ignore space between filepath and hash
                        inputFile.ignore(1); // Ignore starting double quote
                        std::getline(inputFile, hash, ' '); // Read until space
                        std::getline(inputFile, action); // Read until end of line

                        //answered = true;

                        if (status == "found") {
                            addMessage(scrollContent, "Virus found in file: " + scannedFilePath + "\n");
                            addMessage(scrollContent, "File: " + scannedFilePath + " is infected\n");
                            addMessage(scrollContent, "Hash: " + hash + "\n");
                            addMessage(scrollContent, "Action taken: " + action + "\n");
                        }
                        else {
                            addMessage(scrollContent, "No virus found in file: " + scannedFilePath + "\n");
                            addMessage(scrollContent, "File: " + scannedFilePath + " is not infected\n");
                        }
                        addMessage(scrollContent, "------------------------------------------");
                        screen->performLayout();
                    }
                    if (status == "end")
                        answered = true;
                }
                else {
                    //answered = true;
                    addMessage(scrollContent, "Error: Unable to talk to daemon!\n");
                    addMessage(scrollContent, "------------------------------------------");
                    screen->performLayout();
                }
            }
            inputFile.close();
        }
        // Wait for 1 second before checking again
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    // Remove the answer file
    std::remove(ANSWER_COM_PATH);
}

std::string getFolderPath() {
    std::string selectedFolderPath;

    // Initialize COM
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);

    // Display the folder picker dialog
    BROWSEINFO browseInfo = { 0 };
    TCHAR selectedPath[MAX_PATH];
    browseInfo.hwndOwner = NULL; // Use the desktop window as the owner
    browseInfo.pidlRoot = NULL;  // Start from the desktop
    browseInfo.pszDisplayName = selectedPath;
    browseInfo.lpszTitle = TEXT("Select a folder");
    browseInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

    LPITEMIDLIST pidlSelected = SHBrowseForFolder(&browseInfo);
    if (pidlSelected != NULL) {
        SHGetPathFromIDList(pidlSelected, selectedPath);

        // Convert TCHAR array to std::string
        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
        selectedFolderPath = converter.to_bytes(selectedPath);

        // Free the PIDL
        IMalloc* pMalloc;
        if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
            pMalloc->Free(pidlSelected);
            pMalloc->Release();
        }
    }

    // Uninitialize COM
    CoUninitialize();

    return selectedFolderPath;
}

int main() {
    // Initialize NanoGUI
    nanogui::init();

    // Create a NanoGUI screen
    nanogui::Screen screen(nanogui::Vector2i(800, 600), "Cyberhex endpoint protection");

    // Create a layout for the buttons
    nanogui::Widget* buttonWidget = new nanogui::Widget(&screen);
    nanogui::BoxLayout* buttonLayout = new nanogui::BoxLayout(nanogui::Orientation::Vertical,
        nanogui::Alignment::Middle,
        5, 5);
    buttonWidget->setLayout(buttonLayout);

    // Create a button for scanning a file
    nanogui::Button* scanFileButton = new nanogui::Button(buttonWidget, "Scan File");
    scanFileButton->setFixedWidth(150);
    scanFileButton->setCallback([&] {
        // Open file dialog to select a file
        std::string selectedFile = nanogui::file_dialog(
            { {"*", "All Files"} },
            false
        );
        if (!selectedFile.empty()) {
            // Call scan_file function in a separate thread
            std::thread(scan_file, &screen, selectedFile).detach();
        }
        });

    // Create a button for scanning a folder
    nanogui::Button* scanFolderButton = new nanogui::Button(buttonWidget, "Scan Folder");
    scanFolderButton->setFixedWidth(150);
    scanFolderButton->setCallback([&] {
        // Open file dialog to select a folder
        std::string selectedFolder = getFolderPath();
        if (!selectedFolder.empty()) {
            // Call scan_folder function in a separate thread
            std::thread(scan_folder, &screen, selectedFolder).detach();
        }
        });

    // Create a scrollable panel
    nanogui::VScrollPanel* scrollPanel = new nanogui::VScrollPanel(&screen);
    scrollPanel->setFixedWidth(700);
    scrollPanel->setFixedHeight(500);
    nanogui::Widget* scrollContent = new nanogui::Widget(scrollPanel);
    scrollContent->setLayout(new nanogui::BoxLayout(nanogui::Orientation::Vertical, nanogui::Alignment::Minimum, 0, 0));
    scrollPanel->setFixedSize({ 700, 500 });

    // Set the layout for the main screen
    nanogui::BoxLayout* layout = new nanogui::BoxLayout(nanogui::Orientation::Vertical,
        nanogui::Alignment::Minimum,
        10, 10);
    screen.setLayout(layout);

    // Draw NanoGUI
    screen.performLayout();
    screen.setVisible(true);

    // Main event loop
    nanogui::mainloop();

    // Shutdown NanoGUI
    nanogui::shutdown();

    return 0;
}
